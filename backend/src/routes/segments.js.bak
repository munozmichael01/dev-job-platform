const express = require('express');
const router = express.Router();
const { pool, poolConnect, sql } = require('../db/db');

const parseFilters = (filters) => {
  if (!filters) return { jobTitles: [], locations: [], sectors: [], experienceLevels: [], contractTypes: [] };
  try {
    const f = typeof filters === 'string' ? JSON.parse(filters) : filters;
    return {
      jobTitles: f.jobTitles || [],
      locations: f.locations || [],
      sectors: f.sectors || [],
      experienceLevels: f.experienceLevels || [],
      contractTypes: f.contractTypes || [],
    };
  } catch {
    return { jobTitles: [], locations: [], sectors: [], experienceLevels: [], contractTypes: [] };
  }
};

// SOLO activas; locations -> City/Region y combinado; sectors -> Sector; contractTypes -> JobType; jobTitles sin tocar
function buildWhereFromFilters(f, sql) {
  const where = [];
  const inputs = [];

  if (Array.isArray(f.jobTitles) && f.jobTitles.length > 0) {
    const parts = [];
    f.jobTitles.slice(0, 5).forEach((t, i) => {
      parts.push(`Title LIKE @jt${i} OR CompanyName LIKE @jt${i}`);
      inputs.push({ name: `jt${i}`, type: sql.NVarChar, value: `%${t}%` });
    });
    where.push(`(${parts.join(' OR ')})`);
  }

  if (Array.isArray(f.locations) && f.locations.length > 0) {
    const parts = [];
    f.locations.slice(0, 5).forEach((loc, i) => {
      parts.push(`City = @locExact${i} OR Region = @locExact${i} OR
        (CASE WHEN City IS NOT NULL AND Region IS NOT NULL AND Region != '' 
              THEN CONCAT(City, ', ', Region)
              WHEN City IS NOT NULL THEN City ELSE Region END) = @locExact${i}
        OR City LIKE @loc${i} OR Region LIKE @loc${i} OR
        (CASE WHEN City IS NOT NULL AND Region IS NOT NULL AND Region != '' 
              THEN CONCAT(City, ', ', Region)
              WHEN City IS NOT NULL THEN City ELSE Region END) LIKE @loc${i}`);
      inputs.push({ name: `locExact${i}`, type: sql.NVarChar, value: loc });
      inputs.push({ name: `loc${i}`, type: sql.NVarChar, value: `%${loc}%` });
    });
    where.push(`(${parts.join(' OR ')})`);
  }

  if (Array.isArray(f.sectors) && f.sectors.length > 0) {
    const parts = [];
    f.sectors.slice(0, 5).forEach((s, i) => {
      parts.push(`Sector = @secExact${i} OR Sector LIKE @sec${i}`);
      inputs.push({ name: `secExact${i}`, type: sql.NVarChar, value: s });
      inputs.push({ name: `sec${i}`, type: sql.NVarChar, value: `%${s}%` });
    });
    where.push(`(${parts.join(' OR ')})`);
  }

  if (Array.isArray(f.contractTypes) && f.contractTypes.length > 0) {
    const parts = [];
    f.contractTypes.slice(0, 5).forEach((ct, i) => {
      parts.push(`JobType = @ctExact${i} OR JobType LIKE @ct${i}`);
      inputs.push({ name: `ctExact${i}`, type: sql.NVarChar, value: ct });
      inputs.push({ name: `ct${i}`, type: sql.NVarChar, value: `%${ct}%` });
    });
    where.push(`(${parts.join(' OR ')})`);
  }

  where.push(`StatusId = 1`);
  return { where, inputs };
}

router.get('/', async (_req, res) => {
  try {
    await poolConnect;
    const result = await pool.request().query(`
      SELECT Id, Name, Description, Filters, Status, OfferCount, Campaigns, CreatedAt, UpdatedAt
      FROM Segments ORDER BY UpdatedAt DESC
    `);
    const rows = result.recordset.map(r => ({ ...r, Filters: parseFilters(r.Filters) }));
    res.json(rows);
  } catch (e) {
    res.status(500).json({ error: 'Error listando segmentos', details: e.message });
  }
});

router.post('/', async (req, res) => {
  const { name, description = '', filters = {}, status = 'active' } = req.body || {};
  if (!name) return res.status(400).json({ error: 'Campo "name" es requerido' });
  try {
    await poolConnect;
    const now = new Date();
    const insert = await pool.request()
      .input('Name', sql.NVarChar(255), name)
      .input('Description', sql.NVarChar(sql.MAX), description)
      .input('Filters', sql.NVarChar(sql.MAX), JSON.stringify(parseFilters(filters)))
      .input('Status', sql.NVarChar(50), status)
      .input('CreatedAt', sql.DateTime, now)
      .input('UpdatedAt', sql.DateTime, now)
      .query(`
        INSERT INTO Segments (Name, Description, Filters, Status, CreatedAt, UpdatedAt)
        OUTPUT INSERTED.*
        VALUES (@Name, @Description, @Filters, @Status, @CreatedAt, @UpdatedAt)
      `);
    const row = insert.recordset[0];
    res.status(201).json({ ...row, Filters: parseFilters(row.Filters) });
  } catch (e) {
    res.status(500).json({ error: 'Error creando segmento', details: e.message });
  }
});

router.get('/:id', async (req, res) => {
  const id = parseInt(req.params.id);
  try {
    await poolConnect;
    const r = await pool.request().input('Id', sql.Int, id).query(`SELECT * FROM Segments WHERE Id = @Id`);
    if (r.recordset.length === 0) return res.status(404).json({ error: 'Segmento no encontrado' });
    const row = r.recordset[0];
    res.json({ ...row, Filters: parseFilters(row.Filters) });
  } catch (e) {
    res.status(500).json({ error: 'Error obteniendo segmento', details: e.message });
  }
});

router.put('/:id', async (req, res) => {
  const id = parseInt(req.params.id);
  const { name, description, filters, status } = req.body || {};
  try {
    await poolConnect;
    const existing = await pool.request().input('Id', sql.Int, id).query(`SELECT * FROM Segments WHERE Id = @Id`);
    if (existing.recordset.length === 0) return res.status(404).json({ error: 'Segmento no encontrado' });
    const prev = existing.recordset[0];
    const updated = {
      Name: name ?? prev.Name,
      Description: description ?? prev.Description,
      Filters: filters ? JSON.stringify(parseFilters(filters)) : prev.Filters,
      Status: status ?? prev.Status
    };
    const u = await pool.request()
      .input('Id', sql.Int, id)
      .input('Name', sql.NVarChar(255), updated.Name)
      .input('Description', sql.NVarChar(sql.MAX), updated.Description)
      .input('Filters', sql.NVarChar(sql.MAX), updated.Filters)
      .input('Status', sql.NVarChar(50), updated.Status)
      .query(`
        UPDATE Segments
        SET Name=@Name, Description=@Description, Filters=@Filters, Status=@Status, UpdatedAt=GETDATE()
        WHERE Id=@Id;
        SELECT * FROM Segments WHERE Id=@Id;
      `);
    const row = u.recordset[0];
    res.json({ ...row, Filters: parseFilters(row.Filters) });
  } catch (e) {
    res.status(500).json({ error: 'Error actualizando segmento', details: e.message });
  }
});

router.delete('/:id', async (req, res) => {
  const id = parseInt(req.params.id);
  try {
    await poolConnect;
    const c = await pool.request().input('Id', sql.Int, id).query(`SELECT COUNT(*) AS n FROM Campaigns WHERE SegmentId=@Id`);
    if (c.recordset[0].n > 0) return res.status(409).json({ error: 'No se puede eliminar: hay campaÃ±as asociadas' });
    const del = await pool.request().input('Id', sql.Int, id).query(`DELETE FROM Segments WHERE Id=@Id`);
    if (del.rowsAffected[0] === 0) return res.status(404).json({ error: 'Segmento no encontrado' });
    res.status(204).end();
  } catch (e) {
    res.status(500).json({ error: 'Error eliminando segmento', details: e.message });
  }
});

router.get('/:id/estimate', async (req, res) => {
  const id = parseInt(req.params.id);
  try {
    await poolConnect;
    const r = await pool.request().input('Id', sql.Int, id).query(`SELECT Filters FROM Segments WHERE Id=@Id`);
    if (r.recordset.length === 0) return res.status(404).json({ error: 'Segmento no encontrado' });
    const f = parseFilters(r.recordset[0].Filters);

    const { where, inputs } = buildWhereFromFilters(f, sql);
    const whereClause = where.length ? `WHERE ${where.join(' AND ')}` : '';
    const countQuery = `SELECT COUNT(*) AS total FROM JobOffers WITH (READPAST) ${whereClause}`;

    const reqSql = pool.request();
    inputs.forEach(p => reqSql.input(p.name, p.type, p.value));
    const result = await reqSql.query(countQuery);
    res.json({ success: true, count: result.recordset[0].total || 0 });
  } catch (e) {
    res.status(500).json({ error: 'Error estimando ofertas', details: e.message });
  }
});

router.post('/estimate-preview', async (req, res) => {
  const filters = parseFilters(req.body?.filters || {});
  try {
    await poolConnect;
    const { where, inputs } = buildWhereFromFilters(filters, sql);
    const whereClause = where.length ? `WHERE ${where.join(' AND ')}` : '';
    const countQuery = `SELECT COUNT(*) AS total FROM JobOffers WITH (READPAST) ${whereClause}`;

    const reqSql = pool.request();
    inputs.forEach(p => reqSql.input(p.name, p.type, p.value));
    const result = await reqSql.query(countQuery);
    res.json({ success: true, count: result.recordset[0].total || 0 });
  } catch (e) {
    res.status(500).json({ error: 'Error en estimate-preview', details: e.message });
  }
});

module.exports = router;
